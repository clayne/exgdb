

#----add by me----#

    def eax(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register eax')
        return

    def ebx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register ebx')
        return

    def ecx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register ecx')
        return

    def edx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register edx')
        return

    def esi(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register esi')
        return

    def edi(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register edi')
        return

    def ebp(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register ebp')
        return

    def esp(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register esp')
        return

    def eip(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register eip')
        return

    def flg(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register eflags')
        return

    def pc(self,*arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,1)
        arg = arg[0]
        peda.execute('pdisas $eip /%s' % arg)
        return

    def lpout(self,*arg):
        """
        hogehoge
        """
        peda.execute('n $ecx')
        return

    def fullstack(self,*arg):
        """
        hogehoge
        """
        sp = peda.getreg('esp')
        bp = peda.getreg('ebp')
        arg = bp - sp
        arg = arg/4
        arg += 1
        arg = int(arg)
        peda.execute('stack %s' % arg)
        return
    
    def infox(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, regname) = normalize_argv(arg, 2)
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.steip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        msg(text)
        return

    def infox_eip(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, filename) = normalize_argv(arg, 2)
        regname = address
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.steip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        #msg(text)
        os.system('echo ' + '"' + text + '"' + ' >> ./reg/' + filename)
        os.system('cat ./reg/' + filename + ' | tail -1 > ./reg/' + filename + '.tmp')

    def infox_reg(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, filename) = normalize_argv(arg, 2)
        regname = address
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.steip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        #msg(text)
        prev = open('./reg/' + filename + '.tmp', 'r').read()
        if(prev != text+'\n'):
            peda.execute('infox_eip $eip eip')
            os.system('cat ./reg/eip.tmp >> ./reg/' + filename)
            os.system('echo ' + '"' + text + '"' + '>> ./reg/' + filename)
            os.system('cat ./reg/' + filename + ' | tail -1 > ' + './reg/' + filename + '.tmp')
        return

    def regmake(self, *arg):
        """
        Usage: regmake
        """
        os.system('mkdir reg')
        peda.execute('infox_new register eax')
        peda.execute('infox_new register ebx')
        peda.execute('infox_new register ecx')
        peda.execute('infox_new register edx')
        peda.execute('infox_new register esi')
        peda.execute('infox_new register edi')
        peda.execute('infox_new register ebp')
        peda.execute('infox_new register esp')
        peda.execute('infox_new register eip')
        #os.system('touch ./reg/eax')
        #os.system('touch ./reg/ebx')
        #os.system('touch ./reg/ecx')
        #os.system('touch ./reg/edx')
        #os.system('touch ./reg/esi')
        #os.system('touch ./reg/edi')
        #os.system('touch ./reg/ebp')
        #os.system('touch ./reg/esp')
        #os.system('touch ./reg/eip')
        #os.system('touch ./reg/eax.tmp')
        #os.system('touch ./reg/ebx.tmp')
        #os.system('touch ./reg/ecx.tmp')
        #os.system('touch ./reg/edx.tmp')
        #os.system('touch ./reg/esi.tmp')
        #os.system('touch ./reg/edi.tmp')
        #os.system('touch ./reg/ebp.tmp')
        #os.system('touch ./reg/esp.tmp')
        #os.system('touch ./reg/eip.tmp')
        #os.system('touch ./reg/eax.flag')
        #os.system('touch ./reg/ebx.flag')
        #os.system('touch ./reg/ecx.flag')
        #os.system('touch ./reg/edx.flag')
        #os.system('touch ./reg/esi.flag')
        #os.system('touch ./reg/edi.flag')
        #os.system('touch ./reg/ebp.flag')
        #os.system('touch ./reg/esp.flag')
        #os.system('touch ./reg/eip.flag')




    def code(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        arg0 = arg[0]
        arg1 = arg[1]
        eipbk = peda.getreg('eip')
        peda.execute('set $eip=%d' % arg0)
        peda.execute('pc %d' % arg1)
        peda.execute('set $eip=%d' % eipbk)
        return

    def dword(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        addr = arg[0]
        i = arg[1]
        cnt = 0
        while(i > 0):
            peda.execute('infox %d+%d' % (addr,cnt))
            cnt = cnt + 4
            i = i - 1

    def qword(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        addr = arg[0]
        i = arg[1]
        cnt = 0
        while(i > 0):
            peda.execute('infox %d+%d' % (addr,cnt))
            cnt = cnt + 8
            i = i - 1

    def regtrace(self, *arg):
        """
        Usage: regtrace
        """
        arg = normalize_argv(arg,2)
        flag = arg[0]
        file_name = arg[1]
        prev_eax = open('./reg/eax', 'r').read()
        prev_ebx = open('./reg/ebx', 'r').read()
        prev_ecx = open('./reg/ecx', 'r').read()
        prev_edx = open('./reg/edx', 'r').read()
        prev_esi = open('./reg/esi', 'r').read()
        prev_edi = open('./reg/edi', 'r').read()
        prev_ebp = open('./reg/ebp', 'r').read()
        prev_esp = open('./reg/esp', 'r').read()
        prev_eip = open('./reg/eip', 'r').read()
        peda.execute('infox_new register eax')
        peda.execute('infox_new register ebx')
        peda.execute('infox_new register ecx')
        peda.execute('infox_new register edx')
        peda.execute('infox_new register esi')
        peda.execute('infox_new register edi')
        peda.execute('infox_new register ebp')
        peda.execute('infox_new register esp')
        peda.execute('infox_new register eip')
        eax = open('./reg/eax', 'r').read()
        ebx = open('./reg/ebx', 'r').read()
        ecx = open('./reg/ecx', 'r').read()
        edx = open('./reg/edx', 'r').read()
        esi = open('./reg/esi', 'r').read()
        edi = open('./reg/edi', 'r').read()
        ebp = open('./reg/ebp', 'r').read()
        esp = open('./reg/esp', 'r').read()
        eip = open('./reg/eip', 'r').read()
        prev_eip = re.sub(r'\n', '', prev_eip)
        prev_eip = re.sub(r'.*: ', '', prev_eip)
        os.system('echo "\n' + prev_eip + '" >> ./reg/regtrace')
        if(prev_eax != eax):
            eax = re.sub(r'\n', '', eax)
            os.system('echo "' + eax + '" >> ./reg/regtrace')
        if(prev_ebx != ebx):
            ebx = re.sub(r'\n', '', ebx)
            os.system('echo "' + ebx + '" >> ./reg/regtrace')
        if(prev_ecx != ecx):
            ecx = re.sub(r'\n', '', ecx)
            os.system('echo "' + ecx + '" >> ./reg/regtrace')
        if(prev_edx != edx):
            edx = re.sub(r'\n', '', edx)
            os.system('echo "' + edx + '" >> ./reg/regtrace')
        if(prev_esi != esi):
            esi = re.sub(r'\n', '', esi)
            os.system('echo "' + esi + '" >> ./reg/regtrace')
        if(prev_edi != edi):
            edi = re.sub(r'\n', '', edi)
            os.system('echo "' + edi + '" >> ./reg/regtrace')
        if(prev_ebp != ebp):
            ebp = re.sub(r'\n', '', ebp)
            os.system('echo "' + ebp + '" >> ./reg/regtrace')
        if(prev_esp != esp):
            esp = re.sub(r'\n', '', esp)
            os.system('echo "' + esp + '" >> ./reg/regtrace')
        peda.execute('n')
        
    def infox_new(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, regname) = normalize_argv(arg, 2)
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return

        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            tmp = re.sub(r'\n', '', text)
            os.system('echo ' + '"' + text + '"' + ' > ./reg/' + regname)
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                #msg(text.steip())
                a = 'a'
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            text += format_reference_chain(chain) + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
                text += "Virtual memory mapping:\n"
                text += green("Start : %s\n" % to_address(start))
                text += green("End   : %s\n" % to_address(end))
                text += yellow("Offset: 0x%x\n" % (address-start))
                text += red("Perm  : %s\n" % perm)
                text += blue("Name  : %s" % name)
        #msg(text)

        return

    def cc(self, *arg):
        """
        Usage: cc
        """
        while(True):
            peda.execute('ni')
            peda.execute('infox_new register eip')
            eip = open('./reg/eip', 'r').read()
            callOrJmp = re.sub(r'.*call.*', '\\1', eip)
            if(callOrJmp.find(':') == -1):
                break

    def cci(self, *arg):
        """
        Usage: cci
        """
        while(True):
            peda.execute('si')
            peda.execute('infox_new register eip')
            eip = open('./reg/eip', 'r').read()
            callOrJmp = re.sub(r'.*call.*', '\\1', eip)
            if(callOrJmp.find(':') == -1):
                break

    def jj(self, *arg):
        """
        Usage: jj
        """
        while(True):
            peda.execute('ni')
            peda.execute('infox_new register eip')
            eip = open('./reg/eip', 'r').read()
            callOrJmp = re.sub(r'.*(call|jmp|je|jne|jb|ja).*', '\\1', eip)
            if(callOrJmp.find(':') == -1):
                break

    def jji(self, *arg):
        """
        Usage: jji
        """
        while(True):
            peda.execute('si')
            peda.execute('infox_new register eip')
            eip = open('./reg/eip', 'r').read()
            callOrJmp = re.sub(r'.*(call|jmp|je|jne|jb|ja).*', '\\1', eip)
            if(callOrJmp.find(':') == -1):
                break

    def ii(self, *arg):
        """
        Usage: ii
        """
        peda.execute('infox_new register eip')
        eip = open('./reg/eip', 'r').read()
        beforeRegisterX = re.sub(r'.*(e.x).*,.*', '\\1', eip)
        beforeRegisterP = re.sub(r'.*(e.p).*,.*', '\\1', eip)
        beforeRegisterI = re.sub(r'.*(e.i).*,.*', '\\1', eip)
        afterRegisterX = re.sub(r'.*,.*(e.x).*', '\\1', eip)
        afterRegisterP = re.sub(r'.*,.*(e.p).*', '\\1', eip)
        afterRegisterI = re.sub(r'.*,.*(e.i).*', '\\1', eip)
        inregister = re.sub(r'.*(\[.*\]).*', '\\1', eip)
        registerInregister = re.sub(r'.*\[.*(e..).*\].*', '\\1', eip)
        addr = re.sub(r'.*0x.*(0x[0-9a-f][0-9a-f][0-9a-f][0-9a-f]+).*', '\\1', eip)
        if(beforeRegisterX.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterX)
        if(beforeRegisterP.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterP)
        if(beforeRegisterI.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterI)
        if(afterRegisterX.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterX)
        if(afterRegisterP.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterP)
        if(afterRegisterI.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterI)
        if(registerInregister.find(':') == -1):
            peda.execute('xinfo register ' + registerInregister)
        if(addr.find(':') == -1):
            peda.execute('infox ' + addr)
        if inregister.find(':') == -1:
            after = re.sub(r'\n', '', inregister)
            peda.execute("shell echo -n -e '\e[32m" + after + "\e[m: '")
            after = re.sub(r'\[(e..*)\].*', '$\\1', after)
            peda.execute('infox ' + after)

###--------added by me--------------------------------###


