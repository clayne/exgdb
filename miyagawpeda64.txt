

#----add by me----#

    def rax(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rax')
        return

    def rbx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rbx')
        return

    def rcx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rcx')
        return

    def rdx(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rdx')
        return

    def rsi(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rsi')
        return

    def rdi(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rdi')
        return

    def rbp(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rbp')
        return

    def rsp(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rsp')
        return

    def rip(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register rip')
        return

    def flg(self,*arg):
        """
        hogehoge
        """
        peda.execute('xinfo register eflags')
        return

    def pc(self,*arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,1)
        arg = arg[0]
        peda.execute('pdisas $rip /%s' % arg)
        return

    def lpout(self,*arg):
        """
        hogehoge
        """
        peda.execute('n $rcx')
        return

    def fullstack(self,*arg):
        """
        hogehoge
        """
        sp = peda.getreg('rsp')
        bp = peda.getreg('rbp')
        arg = bp - sp
        arg = arg/4
        arg += 1
        arg = int(arg)
        peda.execute('stack %s' % arg)
        return
    
    def infox(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, regname) = normalize_argv(arg, 2)
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.strip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        msg(text)
        return

    def infox_rip(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, filename) = normalize_argv(arg, 2)
        regname = address
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.strip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        #msg(text)
        os.system('echo ' + '"' + text + '"' + ' >> ./reg/' + filename)
        os.system('cat ./reg/' + filename + ' | tail -1 > ./reg/' + filename + '.tmp')

    def infox_reg(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, filename) = normalize_argv(arg, 2)
        regname = address
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return


        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            text += "\n"
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                msg(text.strip())
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            #text += '\n'
            #text += 'info: '
            text += format_reference_chain(chain) # + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
        #msg(text)
        prev = open('./reg/' + filename + '.tmp', 'r').read()
        if(prev != text+'\n'):
            peda.execute('infox_rip $rip rip')
            os.system('cat ./reg/rip.tmp >> ./reg/' + filename)
            os.system('echo ' + '"' + text + '"' + '>> ./reg/' + filename)
            os.system('cat ./reg/' + filename + ' | tail -1 > ' + './reg/' + filename + '.tmp')
        return

    def regmake(self, *arg):
        """
        Usage: regmake
        """
        os.system('mkdir reg')
        peda.execute('infox_new register rax')
        peda.execute('infox_new register rbx')
        peda.execute('infox_new register rcx')
        peda.execute('infox_new register rdx')
        peda.execute('infox_new register rsi')
        peda.execute('infox_new register rdi')
        peda.execute('infox_new register rbp')
        peda.execute('infox_new register rsp')
        peda.execute('infox_new register rip')
        #os.system('touch ./reg/rax')
        #os.system('touch ./reg/rbx')
        #os.system('touch ./reg/rcx')
        #os.system('touch ./reg/rdx')
        #os.system('touch ./reg/rsi')
        #os.system('touch ./reg/rdi')
        #os.system('touch ./reg/rbp')
        #os.system('touch ./reg/rsp')
        #os.system('touch ./reg/rip')
        #os.system('touch ./reg/rax.tmp')
        #os.system('touch ./reg/rbx.tmp')
        #os.system('touch ./reg/rcx.tmp')
        #os.system('touch ./reg/rdx.tmp')
        #os.system('touch ./reg/rsi.tmp')
        #os.system('touch ./reg/rdi.tmp')
        #os.system('touch ./reg/rbp.tmp')
        #os.system('touch ./reg/rsp.tmp')
        #os.system('touch ./reg/rip.tmp')
        #os.system('touch ./reg/rax.flag')
        #os.system('touch ./reg/rbx.flag')
        #os.system('touch ./reg/rcx.flag')
        #os.system('touch ./reg/rdx.flag')
        #os.system('touch ./reg/rsi.flag')
        #os.system('touch ./reg/rdi.flag')
        #os.system('touch ./reg/rbp.flag')
        #os.system('touch ./reg/rsp.flag')
        #os.system('touch ./reg/rip.flag')




    def code(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        arg0 = arg[0]
        arg1 = arg[1]
        ripbk = peda.getreg('rip')
        peda.execute('set $rip=%d' % arg0)
        peda.execute('pc %d' % arg1)
        peda.execute('set $rip=%d' % ripbk)
        return

    def dword(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        addr = arg[0]
        i = arg[1]
        cnt = 0
        while(i > 0):
            peda.execute('infox %d+%d' % (addr,cnt))
            cnt = cnt + 4
            i = i - 1

    def qword(self, *arg):
        """
        hogehoge
        """
        arg = normalize_argv(arg,2)
        addr = arg[0]
        i = arg[1]
        cnt = 0
        while(i > 0):
            peda.execute('infox %d+%d' % (addr,cnt))
            cnt = cnt + 8
            i = i - 1

    def regtrace(self, *arg):
        """
        Usage: regtrace
        """
        arg = normalize_argv(arg,2)
        flag = arg[0]
        file_name = arg[1]
        prev_rax = open('./reg/rax', 'r').read()
        prev_rbx = open('./reg/rbx', 'r').read()
        prev_rcx = open('./reg/rcx', 'r').read()
        prev_rdx = open('./reg/rdx', 'r').read()
        prev_rsi = open('./reg/rsi', 'r').read()
        prev_rdi = open('./reg/rdi', 'r').read()
        prev_rbp = open('./reg/rbp', 'r').read()
        prev_rsp = open('./reg/rsp', 'r').read()
        prev_rip = open('./reg/rip', 'r').read()
        peda.execute('infox_new register rax')
        peda.execute('infox_new register rbx')
        peda.execute('infox_new register rcx')
        peda.execute('infox_new register rdx')
        peda.execute('infox_new register rsi')
        peda.execute('infox_new register rdi')
        peda.execute('infox_new register rbp')
        peda.execute('infox_new register rsp')
        peda.execute('infox_new register rip')
        rax = open('./reg/rax', 'r').read()
        rbx = open('./reg/rbx', 'r').read()
        rcx = open('./reg/rcx', 'r').read()
        rdx = open('./reg/rdx', 'r').read()
        rsi = open('./reg/rsi', 'r').read()
        rdi = open('./reg/rdi', 'r').read()
        rbp = open('./reg/rbp', 'r').read()
        rsp = open('./reg/rsp', 'r').read()
        rip = open('./reg/rip', 'r').read()
        prev_rip = re.sub(r'\n', '', prev_rip)
        prev_rip = re.sub(r'.*: ', '', prev_rip)
        os.system('echo "\n' + prev_rip + '" >> ./reg/regtrace')
        if(prev_rax != rax):
            rax = re.sub(r'\n', '', rax)
            os.system('echo "' + rax + '" >> ./reg/regtrace')
        if(prev_rbx != rbx):
            rbx = re.sub(r'\n', '', rbx)
            os.system('echo "' + rbx + '" >> ./reg/regtrace')
        if(prev_rcx != rcx):
            rcx = re.sub(r'\n', '', rcx)
            os.system('echo "' + rcx + '" >> ./reg/regtrace')
        if(prev_rdx != rdx):
            rdx = re.sub(r'\n', '', rdx)
            os.system('echo "' + rdx + '" >> ./reg/regtrace')
        if(prev_rsi != rsi):
            rsi = re.sub(r'\n', '', rsi)
            os.system('echo "' + rsi + '" >> ./reg/regtrace')
        if(prev_rdi != rdi):
            rdi = re.sub(r'\n', '', rdi)
            os.system('echo "' + rdi + '" >> ./reg/regtrace')
        if(prev_rbp != rbp):
            rbp = re.sub(r'\n', '', rbp)
            os.system('echo "' + rbp + '" >> ./reg/regtrace')
        if(prev_rsp != rsp):
            rsp = re.sub(r'\n', '', rsp)
            os.system('echo "' + rsp + '" >> ./reg/regtrace')
        peda.execute('n')
        
    def infox_new(self, *arg):
        """
        Display detail information of address/registers
        Usage:
            MYNAME address
            MYNAME register [reg1 reg2]
        """

        (address, regname) = normalize_argv(arg, 2)
        if address is None:
            self._missing_argument()

        text = ""
        if not self._is_running():
            return

        def get_reg_text(r, v):
            text = green("%s" % r.upper().ljust(3)) + ": "
            chain = peda.examine_mem_reference(v)
            text += format_reference_chain(chain)
            tmp = re.sub(r'\n', '', text)
            os.system('echo ' + '"' + text + '"' + ' > ./reg/' + regname)
            return text

        (arch, bits) = peda.getarch()
        if str(address).startswith("r"):
            # Register
            regs = peda.getregs(" ".join(arg[1:]))
            if regname is None:
                for r in REGISTERS[bits]:
                    if r in regs:
                        text += get_reg_text(r, regs[r])
            else:
                for (r, v) in sorted(regs.items()):
                    text += get_reg_text(r, v)
            if text:
                #msg(text.strip())
                a = 'a'
            if regname is None or "eflags" in regname:
                self.eflags()
            return

        elif to_int(address) is None:
            warning_msg("not a register nor an address")
        else:
            # Address
            chain = peda.examine_mem_reference(address, depth=0)
            text += format_reference_chain(chain) + "\n"
            vmrange = peda.get_vmrange(address)
            if vmrange:
                (start, end, perm, name) = vmrange
                text += "Virtual memory mapping:\n"
                text += green("Start : %s\n" % to_address(start))
                text += green("End   : %s\n" % to_address(end))
                text += yellow("Offset: 0x%x\n" % (address-start))
                text += red("Perm  : %s\n" % perm)
                text += blue("Name  : %s" % name)
        #msg(text)

        return

    def uu(self, *arg):
        """
        stop.
        """
        args = normalize_argv(arg,1)
        arg = args[0]
        while(True):
            peda.execute('n')
            peda.execute('infox_new register eip')
            eip = open('./reg/eip', 'r').read()
            callOrJmp = re.sub(r'.*' + arg + '.*', '\\1', rip)
            if(callOrJmp.find(':') == -1):
                break

    def cc(self, *arg):
        """
        Usage: cc
        """
        while(True):
            peda.execute('n')
            peda.execute('infox_new register rip')
            rip = open('./reg/rip', 'r').read()
            callOrJmp = re.sub(r'.*call.*', '\\1', rip)
            if(callOrJmp.find(':') == -1):
                break

    def cci(self, *arg):
        """
        Usage: cci
        """
        while(True):
            peda.execute('si')
            peda.execute('infox_new register rip')
            rip = open('./reg/rip', 'r').read()
            callOrJmp = re.sub(r'.*call.*', '\\1', rip)
            if(callOrJmp.find(':') == -1):
                break

    def jj(self, *arg):
        """
        Usage: jj
        """
        while(True):
            peda.execute('n')
            peda.execute('infox_new register rip')
            rip = open('./reg/rip', 'r').read()
            callOrJmp = re.sub(r'.*(call|jmp|je|jne|jb|ja).*', '\\1', rip)
            if(callOrJmp.find(':') == -1):
                break

    def jji(self, *arg):
        """
        Usage: jji
        """
        while(True):
            peda.execute('si')
            peda.execute('infox_new register rip')
            rip = open('./reg/rip', 'r').read()
            callOrJmp = re.sub(r'.*(call|jmp|je|jne|jb|ja).*', '\\1', rip)
            if(callOrJmp.find(':') == -1):
                break

    def ii(self, *arg):
        """
        Usage: ii
        """
        peda.execute('infox_new register rip')
        rip = open('./reg/rip', 'r').read()
        beforeRegisterX = re.sub(r'.*(r.x).*,.*', '\\1', rip)
        beforeRegisterP = re.sub(r'.*(r.p).*,.*', '\\1', rip)
        beforeRegisterI = re.sub(r'.*(r.i).*,.*', '\\1', rip)
        afterRegisterX = re.sub(r'.*,.*(r.x).*', '\\1', rip)
        afterRegisterP = re.sub(r'.*,.*(r.p).*', '\\1', rip)
        afterRegisterI = re.sub(r'.*,.*(r.i).*', '\\1', rip)
        inregister = re.sub(r'.*(\[.*\]).*', '\\1', rip)
        registerInregister = re.sub(r'.*\[.*(r..).*\].*', '\\1', rip)
        addr = re.sub(r'.*0x.*(0x[0-9a-f][0-9a-f][0-9a-f][0-9a-f]+).*', '\\1', rip)
        if(beforeRegisterX.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterX)
        if(beforeRegisterP.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterP)
        if(beforeRegisterI.find(':') == -1):
            peda.execute('xinfo register ' + beforeRegisterI)
        if(afterRegisterX.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterX)
        if(afterRegisterP.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterP)
        if(afterRegisterI.find(':') == -1):
            peda.execute('xinfo register ' + afterRegisterI)
        if(registerInregister.find(':') == -1):
            peda.execute('xinfo register ' + registerInregister)
        if(addr.find(':') == -1):
            peda.execute('infox ' + addr)
        if inregister.find(':') == -1:
            after = re.sub(r'\n', '', inregister)
            peda.execute("shell echo -n -e '\e[32m" + after + "\e[m: '")
            after = re.sub(r'\[(e..*)\].*', '$\\1', after)
            peda.execute('infox ' + after)

###--------added by me--------------------------------###


